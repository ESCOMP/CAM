#!/usr/bin/env perl
#-----------------------------------------------------------------------------------------------
#
# configure
#
#
# This utility allows the CAM user to specify compile-time configuration
# options via a commandline interface.  The output from configure is a
# Makefile and a cache file that contains all configuration parameters
# required to produce the Makefile.  A subsequent invocation of configure
# can use the cache file as input (via the -defaults argument) to reproduce
# the CAM configuration contained in it.  Note that when a cache file is
# used to set default values only the model parameters are used.  The
# parameters that are platform dependent (e.g., compiler options, library
# locations, etc) are ignored.
#
# As the build time configurable options of CAM are changed, this script
# must also be changed.  Thus configure is maintained under revision
# control in the CAM source tree and it is assumed that only the version of
# configure in the source tree will be used to build CAM.  Thus we assume
# that the root of the source tree can be derived from the location of this
# script.
#

use strict;
#use warnings;
#use diagnostics;

use Cwd;
use English;
use Getopt::Long;
use IO::File;
use IO::Handle;

use FindBin qw($Bin);
use lib "$Bin/perl5lib";
use Build::ChemPreprocess qw(chem_preprocess chem_number_adv);
use File::Copy;

#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;
SYNOPSIS
     configure [options]
OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.

  Options used to determine the CAM model configuration.  These options will have an
  effect whether running CAM from CESM scripts or running via CAM standalone scripts:

     -[no]age_of_air_trcs Switch on [off] age of air tracers. Default: on for waccm_phys, otherwise off.
     -analytic_ic       Enables the (namelist controlled) dycore testing infrastructure
     -aquaplanet        Switch on aqua-planet mode.
     -build_chem_proc   Switch forces the build of the chemistry preprocessor (primarily for testing).
     -carma <name>      Build CAM with specified CARMA microphysics model
                        [ none | bc_strat | cirrus | cirrus_dust | dust | meteor_impact |
                          meteor_smoke | mixed_sulfate | pmc | pmc_sulfate | sea_salt | sulfate | tholin |
                          test_detrain | test_growth | test_passive | test_radiative | test_swelling |
                          test_tracers, test_tracers2].
                        Default: none.
     -chem <name>       Build CAM with specified prognostic chemistry package
                        [ trop_mam3 | trop_mam4 | trop_mam7 | trop_mozart |
                          trop_strat_mam4_ts2 | trop_strat_mam4_vbs | trop_strat_mam4_vbsext |
                          waccm_ma | waccm_mad | waccm_mad_mam4 | waccm_ma_mam4 |
                          waccm_ma_sulfur | waccm_sc | waccm_sc_mam4 | waccm_tsmlt_mam4 |
                          terminator | none ].
                        Default: trop_mam4 for cam6 and trop_mam3 for cam5.
     -[no]clubb_sgs     Switch on [off] CLUBB_SGS.  Default: on for cam6, otherwise off.
     -clubb_opts <list> Comma separated list of CLUBB options to turn on/off.  By default they are all off.
                        Current option is: clubb_do_adv (Advect CLUBB moments)
     -co2_cycle         This option modifies the CAM configuration by
                        increasing the number of advected constituents by 4.
     -cosp              Enable the COSP simulator.
     -cppdefs <string>  A string of user specified CPP defines.  Appended to
                        Makefile defaults.  E.g. -cppdefs '-DVAR1 -DVAR2'
     -cpl               Coupling framework [mct | nuopc].  Default: mct.
     -dyn <name>        Dynamical core option: [eul | fv | se | fv3 | mpas].  Default: fv.
     -edit_chem_mech    Invokes CAMCHEM_EDITOR to allow the user to edit the chemistry mechanism file
     -hgrid <name>      Specify horizontal grid.  Use nlatxnlon for spectral grids;
                        dlatxdlon for fv grids (dlat and dlon are the grid cell size
                        in degrees for latitude and longitude respectively); nexnp for
                        se grids.
     -ionosphere        Ionophere module used in WACCMX [ none | wxie ].
     -macrophys <name>  Specify the macrophysics option [rk | park | clubb_sgs].
     -max_n_rad_cnst <n> Maximum number of constituents that are either radiatively
                        active, or in any single diagnostic list for the radiation.
     -microphys <name>  Specify the microphysics option [mg1 | mg2 | mg3| rk].
     -nadv <n>          Set total number of advected species to <n>.
     -nadv_tt <n>       Set number of advected test tracers <n>.
     -nlev <n>          Set number of levels to <n>.
     -offline_dyn       Switch enables the use of offline driver for FV dycore.
     -pbl <name>        Specify the PBL option [uw | hb | hbr].
     -pcols <n>         Set maximum number of columns in a chunk to <n>.
     -pergro            Switch enables building CAM for perturbation growth tests.
     -phys <name>       Physics option [cam3 | cam4 | cam5 | cam6 |
                                        held_suarez | adiabatic | kessler | tj2016 |
                                        spcam_sam1mom | spcam_m2005].  Default: cam6
     -prog_species <list>Comma-separate list of prognostic mozart species packages.
                        Currently available: DST,SSLT,SO4,GHG,OC,BC,CARBON16
     -psubcols <n>      Maximum number of sub-columns in a run - set to 1 if not using sub-columns (default)
     -rad <name>        Specify the radiation package [rrtmg | camrt]
     -silhs             Switch on SILHS.
     -spcam_clubb_sgs   Turn on the SPCAM version of CLUBB
     -spcam_nx <n>      SPCAM x-grid. - defaults to 4 (note the CRM requires spcam_nx to be greater than or equal to 4)
     -spcam_ny <n>      SPCAM y-grid. - defaults to 1
     -spcam_dx <n>      SPCAM horizontal grid spacing.
     -spcam_dt <n>      SPCAM timestep.
     -unicon            Switch to turn on the UNICON scheme. Default: off.
     -usr_mech_infile   Path and file name of the user supplied chemistry mechanism file.
     -waccm_phys        Switch enables the use of WACCM physics in any chemistry configuration.
                        The user does not need to set this if one of the waccm chemistry options
                        is chosen.
     -waccmx            Build CAM/WACCM with WACCM upper Thermosphere/Ionosphere extended package
     -zmconv_org        Include parameterization for sub-grid scale convective organization for the ZM deep convective scheme based
                        on Mapes and Neale (2011)


  Options relevent to SCAM mode:

     -camiop            Configure CAM to generate an IOP file that can be used to drive SCAM.
                        This switch only works with the Eulerian dycore.
     -scam              Compiles model in single column mode.  Only works with Eulerian dycore.

  CAM parallelization:

     -[no]smp           Switch on [off] SMP parallelism.
     -[no]spmd          Switch on [off] SPMD parallelism.

  Configure options:

     -cache <file>      Name of output cache file (default: config_cache.xml).
     -cachedir <file>   Name of directory where output cache file is written (default: CAM build directory).
     -help [or -h]      Print usage to STDOUT.
     -silent [or -s]    Turns on silent mode - only fatal messages issued.
     -verbose [or -v]   Turn on verbose echoing of settings made by configure.
     -version           Echo the CVS tag name used to check out this CAM distribution.

  Options for surface components used in standalone CAM mode:

     -ocn <name>        Build CAM with ocean model [docn | dom | som | socn | aquaplanet | pop]. Default: aquaplanet

  Options for building CAM via standalone scripts:

     -cam_bld <dir>     Directory where CAM will be built.  This is where configure will write the
                        output files it generates (Makefile, Filepath, etc...)
     -cam_exe <name>    Name of the CAM executable (default: cam).
     -cam_exedir <dir>  Directory where CAM executable will be created (default: CAM build directory).
     -cc <name>         User specified C compiler (linux only).  Overrides Makefile default.
     -cflags <string>   A string of user specified C compiler options.  Appended to
                        Makefile defaults.
     -debug             Switch to turn on building CAM with debugging compiler options.
     -cosp_libdir <dir> Directory containing COSP library.
     -esmf_libdir <dir> Directory containing ESMF library and esmf.mk file.
     -fv3core_libdir <dir>  Directory containing FV3 library.
     -fc <name>         User specified Fortran compiler.  Overrides Makefile default.
     -fc_type <name>    Type of Fortran compiler [pgi | intel | gnu | pathscale
                        | ibm | nag].  This argument is used in conjunction
                        with the -fc argument when the name of the fortran
                        compiler refers to a wrapper script (e.g., mpif90
                        or ftn).  In this case the user needs to specify
                        the type of Fortran compiler that is being invoked
                        by the wrapper script.  Default: pgi
     -fflags <string>   A string of user specified Fortran compiler flags.  Appended to
                        Makefile defaults.  See -fopt to override optimization flags.
     -fopt <string>     A string of user specified Fortran compiler optimization flags.
                        Overrides Makefile defaults.
     -gmake <name>      Name of the GNU make program on your system.  Supply the absolute
                        pathname if the program is not in your path (or fix your path).
     -lapack_libdir <dir>
                        Directory containing LAPACK library.
     -ldflags <string>  A string of user specified load options.  Appended to
                        Makefile defaults.
     -linker <name>     User specified linker.  Overrides Makefile default of \$(FC).
     -mpas_libdir <dir> Directory containing MPAS library.
     -mct_libdir <dir>  Directory containing MCT library.  Default: build the library from source
                        in a subdirectory of \$cam_bld.
     -mpi_inc <dir>     Directory containing MPI include files.
     -mpi_lib <dir>     Directory containing MPI library.
     -nc_inc <dir>      Directory containing netCDF include files.
     -nc_lib <dir>      Directory containing netCDF library.
     -nc_mod <dir>      Directory containing netCDF module files.
     -pio2              Switch to turn on building PIO2.  PIO2 is built as a separate library.
                        Default: Use PIO1 and build as part of cam executable.
     -pio2_install_dir <dir> Directory to install PIO2 libraries and include files.  If the libraries
                             already exist then configure will use them in the build.
     -pnc_inc <dir>     Directory containing PnetCDF include files.
     -pnc_lib <dir>     Directory containing PnetCDF library.
     -target_os         Override the os setting for cross platform compilation [aix | darwin | dec_osf |
                        irix | linux | solaris | super-ux | unicosmp | bgl | bgp | bgq].
                        Default: OS on which configure is executing as defined by the
                        perl \$OSNAME variable.
     -usr_src <dir1>[,<dir2>[,<dir3>[...]]]
                        Directories containing user source code.
     -offline_drv <name> Specify offline unit driver [ aur | rad | stub ]

EOF
}

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.

*STDOUT->autoflush();

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CAM configuration scripts.  If the configure command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) {
    $cfgdir = absolute_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "$cfgdir/configure @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = (
            cache       => "config_cache.xml",
            );
GetOptions(
    "age_of_air_trcs!"          => \$opts{'age_of_air_trcs'},
    "analytic_ic"               => \$opts{'analytic_ic'},
    "aquaplanet"                => \$opts{'aquaplanet'},
    "build_chem_proc"           => \$opts{'build_chem_proc'},
    "cache=s"                   => \$opts{'cache'},
    "cachedir=s"                => \$opts{'cachedir'},
    "carma=s"                   => \$opts{'carma'},
    "cam_bld=s"                 => \$opts{'cam_bld'},
    "cam_exe=s"                 => \$opts{'cam_exe'},
    "cam_exedir=s"              => \$opts{'cam_exedir'},
    "camiop"                    => \$opts{'camiop'},
    "cc=s"                      => \$opts{'cc'},
    "cflags=s"                  => \$opts{'cflags'},
    "chem=s"                    => \$opts{'chem'},
    "clubb_sgs!"                => \$opts{'clubb_sgs'},
    "clubb_opts=s"              => \$opts{'clubb_opts'},
    "co2_cycle"                 => \$opts{'co2_cycle'},
    "cosp"                      => \$opts{'cosp'},
    "cosp_libdir=s"             => \$opts{'cosp_libdir'},
    "cppdefs=s"                 => \$opts{'cppdefs'},
    "cpl=s"                     => \$opts{'cpl'},
    "spcam_clubb_sgs"           => \$opts{'spcam_clubb_sgs'},
    "debug"                     => \$opts{'debug'},
    "dyn=s"                     => \$opts{'dyn'},
    "edit_chem_mech"            => \$opts{'edit_chem_mech'},
    "esmf_libdir=s"             => \$opts{'esmf_libdir'},
    "fc=s"                      => \$opts{'fc'},
    "fc_type=s"                 => \$opts{'fc_type'},
    "fflags=s"                  => \$opts{'fflags'},
    "fopt=s"                    => \$opts{'fopt'},
    "fv3core_libdir=s"          => \$opts{'fv3core_libdir'},
    "gmake=s"                   => \$opts{'gmake'},
    "h|help"                    => \$opts{'help'},
    "hgrid=s"                   => \$opts{'hgrid'},
    "ionosphere=s"              => \$opts{'ionosphere'},
    "lapack_libdir=s"           => \$opts{'lapack_libdir'},
    "ldflags=s"                 => \$opts{'ldflags'},
    "linker=s"                  => \$opts{'linker'},
    "macrophys=s"               => \$opts{'macrophys'},
    "max_n_rad_cnst=s"          => \$opts{'max_n_rad_cnst'},
    "mct_libdir=s"              => \$opts{'mct_libdir'},
    "microphys=s"               => \$opts{'microphys'},
    "mpas_libdir=s"             => \$opts{'mpas_libdir'},
    "mpi_inc=s"                 => \$opts{'mpi_inc'},
    "mpi_lib=s"                 => \$opts{'mpi_lib'},
    "nadv=s"                    => \$opts{'nadv'},
    "nadv_tt=s"                 => \$opts{'nadv_tt'},
    "nc_inc=s"                  => \$opts{'nc_inc'},
    "nc_lib=s"                  => \$opts{'nc_lib'},
    "nc_mod=s"                  => \$opts{'nc_mod'},
    "nlev=s"                    => \$opts{'nlev'},
    "ocn=s"                     => \$opts{'ocn'},
    "offline_dyn"               => \$opts{'offline_dyn'},
    "pbl=s"                     => \$opts{'pbl'},
    "pcols=s"                   => \$opts{'pcols'},
    "p|pergro"                  => \$opts{'pergro'},
    "phys=s"                    => \$opts{'phys'},
    "pio2"                      => \$opts{'pio2'},
    "pio2_install_dir=s"        => \$opts{'pio2_install_dir'},
    "pnc_inc=s"                 => \$opts{'pnc_inc'},
    "pnc_lib=s"                 => \$opts{'pnc_lib'},
    "prog_species=s"            => \$opts{'prog_species'},
    "psubcols=s"                => \$opts{'psubcols'},
    "rad=s"                     => \$opts{'rad'},
    "offline_drv=s"             => \$opts{'offline_drv'},
    "scam"                      => \$opts{'scam'},
    "silhs"                     => \$opts{'silhs'},
    "s|silent"                  => \$opts{'silent'},
    "smp!"                      => \$opts{'smp'},
    "spcam_nx=s"                => \$opts{'spcam_nx'},
    "spcam_ny=s"                => \$opts{'spcam_ny'},
    "spcam_dx=s"                => \$opts{'spcam_dx'},
    "spcam_dt=s"                => \$opts{'spcam_dt'},
    "spmd!"                     => \$opts{'spmd'},
    "target_os=s"               => \$opts{'target_os'},
    "unicon"                    => \$opts{'unicon'},
    "usr_mech_infile=s"         => \$opts{'usr_mech_infile'},
    "usr_src=s"                 => \$opts{'usr_src'},
    "v|verbose"                 => \$opts{'verbose'},
    "version"                   => \$opts{'version'},
    "waccm_phys"                => \$opts{'waccm_phys'},
    "waccmx"                    => \$opts{'waccmx'},
    "zmconv_org"                => \$opts{'zmconv_org'},
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Echo version info.
version($cfgdir) if $opts{'version'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }
my $eol = "\n";

my %cfg = ();           # build configuration

#-----------------------------------------------------------------------------------------------
# Make sure we can find required perl modules and configuration files.
# Look for them in the directory that contains the configure script.

# Check for the configuration definition file.
my $config_def_file = "config_files/definition.xml";
(-f "$cfgdir/$config_def_file")  or  die <<"EOF";
** Cannot find configuration definition file \"$config_def_file\" in directory \"$cfgdir\" **
EOF


# Horizontal grid and spectral resolution parameters.
my $horiz_grid_file = 'config_files/horiz_grid.xml';
(-f "$cfgdir/$horiz_grid_file")  or  die <<"EOF";
** Cannot find horizonal grid parameters file \"$horiz_grid_file\" in directory \"$cfgdir\" **
EOF

# The XML::Lite module is required to parse the XML configuration files.
(-f "$cfgdir/perl5lib/XML/Lite.pm")  or  die <<"EOF";
** Cannot find perl module \"XML/Lite.pm\" in directory \"$cfgdir/perl5lib\" **
EOF

# The Build::Config module provides utilities to store and manipulate the configuration.
(-f "$cfgdir/perl5lib/Build/Config.pm")  or  die <<"EOF";
** Cannot find perl module \"Build/Config.pm\" in directory \"$cfgdir/perl5lib\" **
EOF

if ($print>=2) { print "CAM configuration script directory: $cfgdir$eol"; }

#-----------------------------------------------------------------------------------------------
# Add $cfgdir/perl5lib to the list of paths that Perl searches for modules
unshift @INC, "$cfgdir/perl5lib";
unshift @INC, "$cfgdir";
require XML::Lite;
require Build::Config;

# Initialize the configuration.  The $config_def_file provides the definition of a CAM
# configuration.  $cfg_ref is a reference to the new configuration object.
my $cfg_ref = Build::Config->new("$cfgdir/$config_def_file");

#-----------------------------------------------------------------------------------------------
# CAM root directory.
# Check for standalone or CESM checkout
my $cam_root = absolute_path("$cfgdir/..");
my $cam_dir = $cam_root;
if (! -d "$cam_root/cime") {
  $cam_root = absolute_path("$cfgdir/../../..");
}
if (-d "$cam_root/components/cam/src") {
    $cfg_ref->set('cam_root', $cam_root);
    $cam_dir = "$cam_root/components/cam";
    $cfg_ref->set('cam_dir', $cam_dir);
}
elsif (-d "$cam_root/src") {
    $cfg_ref->set('cam_root', $cam_root);
    $cfg_ref->set('cam_dir', $cam_dir);
} else {
    die <<"EOF";
** Invalid CAM root directory: $cam_root
**
** The CAM root directory must contain the subdirectory components/cam/src/
** (CESM checkout) or the subdirectory src (standalone checkout).
** For CESM checkouts, it is derived from "config_dir/../../..".
** For CAM standalone checkouts, it is derived from"config_dir/..",
** where config_dir is the directory in the CAM distribution that
** contains the configuration scripts.
** scripts.
EOF
}

if ($print>=2) { print "CAM root directory: $cam_root$eol"; }

#-----------------------------------------------------------------------------------------------
# CAM build directory.
my $cam_bld;
if (defined $opts{'cam_bld'}) {
    $cam_bld = absolute_path($opts{'cam_bld'});
}
else { # use default value
    $cam_bld = absolute_path($cfg_ref->get('cam_bld'));
}

if (-d $cam_bld or mkdirp($cam_bld)) {
    # If the build directory exists or can be made then set the value...
    $cfg_ref->set('cam_bld', $cam_bld);
}
else {
    die <<"EOF";
** Could not create the specified CAM build directory: $cam_bld
EOF
}

if ($print>=2) { print "CAM build directory: $cam_bld$eol"; }

#-----------------------------------------------------------------------------------------------
# CAM install directory.
my $cam_exedir;
if (defined $opts{'cam_exedir'}) {
    $cam_exedir = absolute_path($opts{'cam_exedir'});
}
else { # use default value
    $cam_exedir = absolute_path($cfg_ref->get('cam_exedir'));
}

#-----------------------------------------------------------------------------------------------
# User source directories.
my $usr_src = '';
if (defined $opts{'usr_src'}) {
    my @dirs = split ',', $opts{'usr_src'};
    my @adirs;
    while ( my $dir = shift @dirs ) {
        if (-d "$dir") {
            push @adirs, absolute_path($dir);
        } else {
            die "** User source directory does not exist: $dir\n";
        }
    }
    $usr_src = join ',', @adirs;
    $cfg_ref->set('usr_src', $usr_src);
}

if ($print>=2) { print "User source directories: $usr_src$eol"; }

#-----------------------------------------------------------------------------------------------
# configuration cache directory and file.
my $config_cache_dir;
my $config_cache_file;
if (defined $opts{'cachedir'}) {
    $config_cache_dir = absolute_path($opts{'cachedir'});
}
else {
    $config_cache_dir = $cfg_ref->get('cam_bld');
}

if (-d $config_cache_dir or mkdirp($config_cache_dir)) {
    $config_cache_file = "$config_cache_dir/$opts{'cache'}";
} else {
    die <<"EOF";
** Could not create the specified directory for configuration cache file: $config_cache_dir
EOF
}

if ($print>=2) { print "Configuration cache file: $config_cache_file$eol"; }

#-----------------------------------------------------------------------------------------------
# Platform properties ##########################################################################
#-----------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------
# Determine target OS -- allow cross compilation only if target_os is specified on commandline.
my $target_os = $OSNAME;
if (defined $opts{'target_os'}) {
    $target_os = $opts{'target_os'};
}
$cfg_ref->set('target_os', $target_os);

if ($print>=2) { print "Target OS: $target_os$eol"; }

#-----------------------------------------------------------------------------------------------
# SPMD
my $spmd_val = 0;
if (defined $opts{'spmd'}) {
    $spmd_val = $opts{'spmd'};
}
$cfg_ref->set('spmd', $spmd_val);

my $spmd = $spmd_val ? 'ON': 'OFF';
if ($print>=2) { print "SPMD parallelism: $spmd$eol";}

#-----------------------------------------------------------------------------------------------
# SMP
my $smp_val = 0;
if (defined $opts{'smp'}) {
    $smp_val = $opts{'smp'}
}
$cfg_ref->set('smp', $smp_val);

my $smp = $smp_val ? 'ON': 'OFF';
if ($print>=2) { print "SMP parallelism: $smp$eol";}

#-----------------------------------------------------------------------------------------------
# Determine which packages/component to include  ###############################################
#-----------------------------------------------------------------------------------------------

# Coupling framework

if (defined $opts{'cpl'}) {
    $cfg_ref->set('cpl', $opts{'cpl'});
}

my $cpl = $cfg_ref->get('cpl');
if ($print>=2) { print "Coupling framework: $cpl$eol"; }

#-----------------------------------------------------------------------------------------------
# Physics package
#
# The default physics package is cam6.  Physics packages >=cam5 use chemistry packages
# that include modal aerosols, i.e., the -chem value matches /_mam/.  If the chem_pkg
# name doesn't match /_mam/ then set the default physics package to cam4.
my $phys_pkg = 'cam6';
if (defined $opts{'chem'} and $opts{'chem'} !~ /_mam/) {
    $phys_pkg = 'cam4';
}
elsif (defined $opts{'waccmx'}) {
    $phys_pkg = 'cam4';
}

# user override
if (defined $opts{'phys'}) {
    $phys_pkg = lc($opts{'phys'});
}

# Add to the config object.
$cfg_ref->set('phys', $phys_pkg);

if ($print>=2) { print "Physics package: $phys_pkg$eol"; }


# Set flag to indicate a simple physics option
my $simple_phys = 0;
if ($phys_pkg =~ m/^adiabatic$|^held_suarez$|^kessler$|^tj2016$/) {
    $simple_phys = 1;
}

#-----------------------------------------------------------------------------------------------
# Chemistry package

my $chem_pkg = 'trop_mam4';

# defaults based on physics package
if ($simple_phys or $phys_pkg =~ m/^cam[34]$/ or $phys_pkg eq 'spcam_sam1mom') {
    $chem_pkg = 'none';
}
elsif ($phys_pkg eq 'cam5' or $phys_pkg eq 'spcam_m2005') {
    $chem_pkg = 'trop_mam3';
}

# some overrides for special configurations
if (defined $opts{'prog_species'}) {
    $chem_pkg = 'none';
}
elsif (defined $opts{'waccmx'}) {
    $chem_pkg = 'waccm_ma';
}

# Allow the user to override the default chemistry via the commandline.
if (defined $opts{'chem'}) {
    $chem_pkg = lc($opts{'chem'});

    # But do some consistency checks...

    # If the user has specified a simple physics package...
    if ($simple_phys) {
        # the only valid chemistry options are 'none' and 'terminator'
        if (($chem_pkg ne 'none') and ($chem_pkg ne 'terminator')) {
            die "configure ERROR: -phys=$phys_pkg  -chem=$chem_pkg\n".
                "                 -chem can only be set to 'none' or 'terminator'.\n";
        }
    }
    elsif ($phys_pkg =~ m/^cam3$|^cam4$|^spcam_sam1mom$/) {
        # The modal aerosols are not valid with cam3 or cam4 physics
        if ($chem_pkg =~ /_mam/) {
            die "configure ERROR: -phys=$phys_pkg  -chem=$chem_pkg\n".
                "                 -chem cannot be set to a modal aerosol option.\n";
        }
    }

    if (defined $opts{'prog_species'}) {
        if ($chem_pkg !~ /none/) {
            die "configure ERROR: -prog_species=$opts{'prog_species'}  -chem=$chem_pkg\n".
                "                 -chem must be set 'none' with the prog_species option.\n";
        }
    }

    if (defined $opts{'waccmx'}) {
        if ($chem_pkg !~ /waccm_ma/) {
            die "configure ERROR: -waccmx=$opts{'waccmx'}  -chem=$chem_pkg\n".
                "                 -chem must be set 'waccm_ma*' with the waccmx option.\n";
        }
    }

}

# Add to the config object.
$cfg_ref->set('chem', $chem_pkg);

if ($print>=2) { print "Chemistry package: $chem_pkg$eol"; }

#-----------------------------------------------------------------------------------------------
# Dynamics package
$cfg_ref->set('dyn', 'fv');

if (defined $opts{'dyn'}) {
    $cfg_ref->set('dyn', lc($opts{'dyn'}) );
}
my $dyn_pkg = $cfg_ref->get('dyn');

if ($dyn_pkg eq 'fv3' and $spmd eq 'OFF') {
    die "configure: FATAL: the fv3 dycore requires at least 6 tasks SPMD must not be switched off.$eol";
}

if ($print>=2) { print "Dynamics package: $dyn_pkg$eol"; }

$cfg_ref->set('analytic_ic', (defined $opts{'analytic_ic'}) ? $opts{'analytic_ic'} : 0);

# offline driver
if (defined $opts{'offline_dyn'}) {
    $cfg_ref->set('offline_dyn', $opts{'offline_dyn'});
}
my $offline_dyn = $cfg_ref->get('offline_dyn');

# offline driver only runs with FV dycore
if ( ($offline_dyn) and ($dyn_pkg ne 'fv') ) {
    die <<"EOF";
** ERROR: Offline driver only applicable to the FV dycore.
EOF
}

#-----------------------------------------------------------------------------------------------
# Test tracer package
if (defined $opts{'nadv_tt'}) {
    $cfg_ref->set('nadv_tt', $opts{'nadv_tt'});
}
my $ttrac_nadv = $cfg_ref->get('nadv_tt');

if ($print>=2) { print "Number of user requested test tracers: $ttrac_nadv$eol"; }


#-----------------------------------------------------------------------------------------------
# Radiatively active constituents.
if (defined $opts{'max_n_rad_cnst'}) {
    $cfg_ref->set('max_n_rad_cnst', $opts{'max_n_rad_cnst'});
}
my $max_n_rad_cnst = $cfg_ref->get('max_n_rad_cnst');

if ($print>=2) { print "Maximum radiatively active tracers: $max_n_rad_cnst$eol"; }

#-----------------------------------------------------------------------------------------------
# waccm physics
my $waccm_phys = 0;
if ($chem_pkg =~ /waccm_/) {
    $waccm_phys = 1;
}
$cfg_ref->set('waccm_phys', $waccm_phys);

# user override
if (defined $opts{'waccm_phys'}) {
    $cfg_ref->set('waccm_phys', $opts{'waccm_phys'});
}
$waccm_phys = $cfg_ref->get('waccm_phys');

if ($print>=2) { print "WACCM physics: $waccm_phys$eol"; }


# WACCM physics only runs with FV, SE and FV3 dycores
if ( ($waccm_phys) and ($dyn_pkg eq 'eul') ) {
    die <<"EOF";
** ERROR: WACCM physics does not run with the Eulerian spectral dycore.
EOF
}

# WACCM includes 4 age of air tracers by default
if ($chem_pkg =~ /waccm_ma/ or $chem_pkg =~ /waccm_tsmlt/) {
    $cfg_ref->set('age_of_air_trcs', 1);
}

# Allow user to override WACCM default, or turn on the age of air tracers
# in non-WACCM runs.
if (defined $opts{'age_of_air_trcs'}) {
    $cfg_ref->set('age_of_air_trcs', $opts{'age_of_air_trcs'});
}
my $age_of_air_trcs = $cfg_ref->get('age_of_air_trcs') ? "ON" : "OFF";

if ($print>=2) { print "Age of air tracer package: $age_of_air_trcs$eol"; }

# waccmx option
if (defined $opts{'waccmx'}) {
    $cfg_ref->set('waccmx', $opts{'waccmx'});
    if (defined $opts{'ionosphere'}) {
       $cfg_ref->set('ionosphere', $opts{'ionosphere'});
    }
}
my $waccmx = $cfg_ref->get('waccmx');
my $ionos  = $cfg_ref->get('ionosphere');

#-----------------------------------------------------------------------------------------------

# Prognostic species package(s)
if (defined $opts{'prog_species'}) {
    $cfg_ref->set('prog_species', $opts{'prog_species'});
    if ($chem_pkg ne 'none'){
        die "ERROR: chem and prog_species cannot be both specified.\n";
      }
}
if (defined $opts{'edit_chem_mech'}) {
    $cfg_ref->set('edit_chem_mech', $opts{'edit_chem_mech'});
}
if (defined $opts{'usr_mech_infile'}) {
    $cfg_ref->set('usr_mech_infile', $opts{'usr_mech_infile'});
}

#-----------------------------------------------------------------------------------------------
# Prognostic aerosol/GHG package(s)
my $prog_species = $cfg_ref->get('prog_species');

if (($waccm_phys) and ($chem_pkg eq 'none') and !($prog_species)) {
    die <<"EOF";
** ERROR: WACCM physics only runs with chemistry.
EOF
}

#-----------------------------------------------------------------------------------------------
# Biogeochemistry option
if (defined $opts{'co2_cycle'}) {
    $cfg_ref->set('co2_cycle', $opts{'co2_cycle'});
}
my $co2_cycle = $cfg_ref->get('co2_cycle');

if ($co2_cycle and $print>=2) { print "co2_cycle option: ON$eol"; }

#-----------------------------------------------------------------------------------------------
# Superparameterization mode (SPCAM)
#
# These values all default to 1 unless specified by the user during configure

if ($phys_pkg eq 'spcam_sam1mom' or $phys_pkg eq 'spcam_m2005') {

    if ($smp eq 'ON') {
        die "ERROR: SPCAM may not be used with threading $eol";
    }

   if ($print>=2) {print "Configure CAM for SPCAM (superparameterization) mode: $phys_pkg.$eol"; }

   if (defined $opts{'spcam_nx'}) {
       $cfg_ref->set('spcam_nx', $opts{'spcam_nx'});
       my $spcam_nx = $cfg_ref->get('spcam_nx');
       if ($spcam_nx < 4) {
          die "configure ERROR: spcam_nx must be greater than or equal to 4\n";
       }
       if ($print>=2) {print "spcam_nx= $spcam_nx $eol"; }
   }
   if (defined $opts{'spcam_ny'}) {
       $cfg_ref->set('spcam_ny', $opts{'spcam_ny'});
       my $spcam_ny = $cfg_ref->get('spcam_ny');
       if ($print>=2) {print "spcam_ny= $spcam_ny $eol"; }
   }
   if (defined $opts{'spcam_dx'}) {
       $cfg_ref->set('spcam_dx', $opts{'spcam_dx'});
       my $spcam_dx = $cfg_ref->get('spcam_dx');
       if ($print>=2) {print "spcam_nx= $spcam_dx $eol"; }
   }
   if (defined $opts{'spcam_dt'}) {
       $cfg_ref->set('spcam_dt', $opts{'spcam_dt'});
       my $spcam_dt = $cfg_ref->get('spcam_dt');
       if ($print>=2) {print "spcam_nt= $spcam_dt $eol"; }
   }

}


#-----------------------------------------------------------------------------------------------
# Micro-physics package

# Set default
my $microphys_pkg = 'none';
if ($phys_pkg =~ m/^cam[34]$/) {
    $microphys_pkg = 'rk';
}
elsif ($phys_pkg eq 'cam5') {
    $microphys_pkg = 'mg1';
}
elsif ($phys_pkg eq 'cam6') {
    $microphys_pkg = 'mg2';
}
elsif ($phys_pkg eq 'spcam_sam1mom') {
    $microphys_pkg = 'spcam_sam1mom';
}
elsif ($phys_pkg eq 'spcam_m2005') {
    $microphys_pkg = 'spcam_m2005';
}

# Allow the user to override the default via the commandline.
if (defined $opts{'microphys'}) {
    $microphys_pkg = lc($opts{'microphys'});
}

$cfg_ref->set('microphys', $microphys_pkg);

if ($print>=2) { print "Microphysics package: $microphys_pkg$eol"; }

#-----------------------------------------------------------------------------------------------
# CARMA sectional microphysics package
# The default for the current physics package is:
my  $carma_pkg = 'none';

# Allow the user to override the default via the commandline.
if (defined $opts{'carma'}) {
    $carma_pkg = lc($opts{'carma'});
}

if ($carma_pkg =~ m/cirrus/i) {
    unless ($microphys_pkg =~ /^mg/) {
        die <<"EOF";
**    ERROR: microphysics package set to: $microphys_pkg
**    The CARMA cirrus model only works with MG microphysics.
EOF
    }
}

$cfg_ref->set('carma', $carma_pkg);

if ($print>=2) { print "CARMA microphysical model: $carma_pkg$eol"; }

#-----------------------------------------------------------------------------------------------
# CLUBB
my $clubb_sgs = 0;
if ($phys_pkg eq 'cam6') {
    $clubb_sgs = 1;
}

# user override
if (defined $opts{'clubb_sgs'}) {
    $clubb_sgs = $opts{'clubb_sgs'};
}

# consistency checks...

# CLUBB_SGS only works with mg microphysics
if ($clubb_sgs and not ($microphys_pkg =~ m/^mg/ )) {
    die <<"EOF";
**    ERROR: microphysics package set to: $microphys_pkg
**    CLUBB_SGS only works with MG microphysics.
EOF
}

$cfg_ref->set('clubb_sgs', $clubb_sgs);

if ($print>=2) { print "clubb_sgs: $clubb_sgs$eol"; }

#-----------------------------------------------------------------------------------------------
# SILHS
my $silhs = 0;
# user override
if (defined $opts{'silhs'}) {
    $silhs = $opts{'silhs'};
}

# SILHS only works with CLUBB_SGS
if ($silhs and not ($clubb_sgs )) {
    die <<"EOF";
**    ERROR: SILHS is turned on, but CLUBB_SGS is not
EOF
}

$cfg_ref->set('silhs', $silhs);

if ($print>=2) { print "silhs: $silhs$eol"; }

#-----------------------------------------------------------------------------------------------
# SPCAM version of CLUBB
if (defined $opts{'spcam_clubb_sgs'}) {
    $cfg_ref->set('spcam_clubb_sgs', $opts{'spcam_clubb_sgs'});
}
my $spcam_clubb_sgs = $cfg_ref->get('spcam_clubb_sgs');


#-----------------------------------------------------------------------------------------------
# Break apart CLUBB options into separate fields

if (defined $opts{'clubb_opts'}) {
     my @clubb_temp_opts = split /,/, $opts{'clubb_opts'};
     foreach (@clubb_temp_opts) {
        $cfg_ref->set("$_", '1');
     }
}
my $clubb_do_adv = $cfg_ref->get('clubb_do_adv');
if ($print>=2) { print "clubb_do_adv: $clubb_do_adv$eol"; }

#-----------------------------------------------------------------------------------------------
# ZM convective organization

if (defined $opts{'zmconv_org'}) {
    $cfg_ref->set('zmconv_org', $opts{'zmconv_org'});
}

my $zmconv_org = $cfg_ref->get('zmconv_org');
if ($print>=2) { print "zmconv_org: $zmconv_org$eol"; }

#-----------------------------------------------------------------------------------------------
# Macro-physics package

# Set default
my $macrophys_pkg = 'none';
if ($phys_pkg =~ /cam[34]/) {
    $macrophys_pkg = 'rk';
}
elsif ($phys_pkg =~ /cam5/) {
    $macrophys_pkg = 'park';
}
elsif ($phys_pkg =~ /cam6/ and $clubb_sgs) {
    $macrophys_pkg = 'clubb_sgs';
}
elsif ($phys_pkg =~ /cam6/ and !$clubb_sgs) {
    $macrophys_pkg = 'park';
}
elsif ($phys_pkg eq 'spcam_sam1mom') {
    $macrophys_pkg = 'spcam_sam1mom';
}
elsif ($phys_pkg eq 'spcam_m2005') {
    $macrophys_pkg = 'spcam_m2005';
}

# user overrides
if ($clubb_sgs or $spcam_clubb_sgs) {
  $macrophys_pkg = 'clubb_sgs';
}

if (defined $opts{'macrophys'}) {
    $macrophys_pkg = lc($opts{'macrophys'});
}

$cfg_ref->set('macrophys', $macrophys_pkg);

if ($print>=2) { print "Macrophysics package: $macrophys_pkg$eol"; }


#-----------------------------------------------------------------------------------------------
# PBL package

# Set default:
my $pbl_pkg = 'none';
if ($phys_pkg =~ m/^cam[34]$/) {
    $pbl_pkg = 'hb';
}
elsif ($phys_pkg =~ /cam5/) {
    $pbl_pkg = 'uw';
}
elsif ($phys_pkg =~ /cam6/ and $clubb_sgs) {
    $pbl_pkg = 'clubb_sgs';
}
elsif ($phys_pkg =~ /cam6/ and !$clubb_sgs) {
    $pbl_pkg = 'uw';
}
elsif ($phys_pkg eq 'spcam_sam1mom') {
    $pbl_pkg = 'spcam_sam1mom';
}
elsif ($phys_pkg eq 'spcam_m2005') {
    $pbl_pkg = 'spcam_m2005';
}

# Allow the user to override the default via the commandline.
if ($clubb_sgs == 1) {
    $pbl_pkg = 'clubb_sgs';
}
if (defined $opts{'pbl'}) {
    $pbl_pkg = lc($opts{'pbl'});
}

# consistency checks...

# UW PBL only works with mg microphysics
if ($pbl_pkg =~ m/uw/i) {
    unless ($microphys_pkg =~ /^mg/) {
        die <<"EOF";
**    ERROR: microphysics package set to: $microphys_pkg
**    The UW PBL scheme only works with MG microphysics.
EOF
    }
}

$cfg_ref->set('pbl', $pbl_pkg);

if ($print>=2) { print "PBL package: $pbl_pkg$eol"; }

#-----------------------------------------------------------------------------------------------
# UNICON

if (defined $opts{'unicon'}) {
    $cfg_ref->set('unicon', $opts{'unicon'});
}
my $unicon = $cfg_ref->get('unicon');

# consistency checks...

# UNICON assumes park macrophysics, uw pbl, and mg microphysics
if ($unicon and
    ($macrophys_pkg ne 'park' or $pbl_pkg ne 'uw' or $microphys_pkg !~ m/^mg/) ) {
    die <<"EOF";
**    ERROR: UNICON assumes macrophys='park', pbl='uw', microphys='mg*'.  Current values are:
**    macrophys: $macrophys_pkg, pbl: $pbl_pkg, microphys: $microphys_pkg.
EOF
}

if ($unicon and $print>=2) { print "Using UNICON scheme.$eol"; }

#-----------------------------------------------------------------------------------------------
# Radiation package

# Set default
my $rad_pkg = 'none';
if ($phys_pkg =~ m/^cam[34]$|^spcam_sam1mom$/) {
    $rad_pkg = 'camrt';
}
elsif ($phys_pkg =~ m/^cam[56]$|^spcam_m2005$/) {
    $rad_pkg = 'rrtmg';
}

# Allow the user to override the default via the commandline.
if (defined $opts{'rad'}) {
    $rad_pkg = lc($opts{'rad'});
}

# consistency checks...

if ($rad_pkg eq 'camrt') {

    # The camrt radiation doesn't work with the modal aerosols
    if ($chem_pkg =~ /_mam/) {
        die "configure ERROR: radiation package: $rad_pkg is not compatible\n".
            "                 with aerosol package $chem_pkg\n";
    }
}
elsif ($rad_pkg eq 'rrtmg') {

    # The rrtmg package doesn't work with the CAM3 prescribed aerosols
    if ($phys_pkg eq 'cam3') {
        die "configure ERROR: radiation package: $rad_pkg is not compatible\n".
            "                 with physics package $phys_pkg\n";
    }
}

$cfg_ref->set('rad', $rad_pkg);

if ($print>=2) { print "Radiation package: $rad_pkg$eol"; }

#-----------------------------------------------------------------------------------------------
# Option to build the COSP simulator
if (defined $opts{'cosp'}) {
    $cfg_ref->set('cosp', $opts{'cosp'});
}
my $cosp = $cfg_ref->get('cosp');

# cosp is only implemented with the cam5 and cam6 physics packages
if ($cosp and ($phys_pkg ne 'cam5' and $phys_pkg ne 'cam6')) {
        die "configure ERROR: cosp not implemented for the $phys_pkg physics package \n";
}

if ($cosp and $print>=2) { print "COSP simulator enabled$eol"; }

#-----------------------------------------------------------------------------------------------
# Checks for SPCAM compatability

if ($phys_pkg eq 'spcam_sam1mom') {
   if ($rad_pkg ne 'camrt') {
        die "configure ERROR: radiation package: $rad_pkg is not compatible\n".
            "                 with sam1mom -- it should be camrt\n";
  }
   if ($chem_pkg ne 'none') {
        die "configure ERROR: chemistry package: $chem_pkg is not compatible\n".
            "                 with sam1mom -- it should be none\n";
  }
}

if ($phys_pkg eq 'spcam_m2005') {
   if ($rad_pkg ne 'rrtmg') {
        die "configure ERROR: radiation package: $rad_pkg is not compatible\n".
            "                 with m2005 -- it should be rrtmg\n";
  }
   if ($chem_pkg ne 'trop_mam3') {
        die "configure ERROR: chemistry package: $chem_pkg is not compatible\n".
            "                 with m2005 -- it should be trop_mam3\n";
  }
}

#-----------------------------------------------------------------------------------------------
# offline unit driver
if (defined $opts{'offline_drv'}) {
    $cfg_ref->set('offline_drv', $opts{'offline_drv'});
}

#-----------------------------------------------------------------------------------------------
# Aquaplanet mode
# This provides a flag to CAM to let it know that it's running in aquaplanet mode.
# This flag is mainly used by the dycore to set the fixed dry mass of the atmosphere.
# It is independent of which model is used to specify the aquaplanet surface properties.
my $aquaplanet = 0;

# user override
if (defined $opts{'aquaplanet'}) {
    $aquaplanet = 1;
}

$cfg_ref->set('aquaplanet', $aquaplanet);

my $aqua_mode = $aquaplanet ? "ON" : "OFF";
if ($print>=2) { print "Aqua-planet mode: $aqua_mode$eol"; }

#-----------------------------------------------------------------------------------------------
# Ocean model
my $ocn_pkg = 'socn';
if ($aquaplanet) {
    # Default for aquaplanet mode is to use an analytic expression for fixed SST.
    $ocn_pkg = 'aquaplanet';
}

# Allow the user to override the default via the commandline.
# For aquaplanet with SOM the option '-ocn som' should be used to override
# aquaplanet's default ocean component setting.
if (defined $opts{'ocn'}) {
    $ocn_pkg = lc($opts{'ocn'});
}

$cfg_ref->set('ocn', $ocn_pkg);

if ($print>=2) { print "Ocean package: $ocn_pkg$eol"; }

#-----------------------------------------------------------------------------------------------
# Use modifications for perturbation growth testing?
if (defined $opts{'pergro'}) {
    $cfg_ref->set('pergro', $opts{'pergro'});
}
my $pergro = $cfg_ref->get('pergro') ? "ON" : "OFF";

if ($print>=2) { print "Perturbation growth testing: $pergro$eol"; }

#-----------------------------------------------------------------------------------------------
# Single column mode
if (defined $opts{'scam'}) {
    $cfg_ref->set('scam', 1);
}
my $scam = $cfg_ref->get('scam') ? "ON" : "OFF";

# The only dycore supported in SCAM mode is Eulerian
if ($scam eq 'ON' and $dyn_pkg ne 'eul') {
    die <<"EOF";
**  ERROR: SCAM mode only works with Eulerian dycore.
**         Requested dycore is: $dyn_pkg
EOF
}

if ($print>=2) { print "CAM single column mode (SCAM): $scam$eol"; }

#-----------------------------------------------------------------------------------------------
# Generate IOP
if (defined $opts{'camiop'}) {
    $cfg_ref->set('camiop', 1);
}
my $camiop = $cfg_ref->get('camiop') ? "ON" : "OFF";

# The only dycore supported in CAMIOP mode is Eulerian
if ($camiop eq 'ON' and $dyn_pkg ne 'eul') {
    die <<"EOF";
**  ERROR: CAMIOP mode only works with Eulerian dycore.
**         Requested dycore is: $dyn_pkg
EOF
}

if ($print>=2) { print "Produce IOP file for SCAM: $camiop$eol"; }

#-----------------------------------------------------------------------------------------------
# Horizontal grid parameters
# Dycore dependent defaults:
my $hgrid;
if ($dyn_pkg eq 'fv') {
    $hgrid = '1.9x2.5';
}
elsif ($dyn_pkg eq 'eul') {
    $hgrid = '64x128';
}
elsif ($dyn_pkg eq 'se') {
    $hgrid = 'ne16np4';
}
elsif ($dyn_pkg eq 'mpas') {
    $hgrid = 'mpasa480';
}
$cfg_ref->set('hgrid', $hgrid);

# User override.
if (defined $opts{'hgrid'}) {
    $cfg_ref->set('hgrid', $opts{'hgrid'});
}
my $hgrid = $cfg_ref->get('hgrid');

# set_horiz_grid sets the parameters for specific dycore/hgrid combinations.
set_horiz_grid("$cfgdir/$horiz_grid_file", $cfg_ref);

if ($print>=2) { print "Horizontal grid specifier: $hgrid$eol"; }

#-----------------------------------------------------------------------------------------------
# Maximum number of columns in a chunk.
if (defined $opts{'pcols'}) {
    $cfg_ref->set('pcols', $opts{'pcols'});
}
my $pcols = $cfg_ref->get('pcols');

# Override PCOLS setting if configuring for SCAM
if ($scam eq 'ON') {
    $pcols = 1;
    $cfg_ref->set('pcols', $pcols);
}

# Check valid value of pcols
unless ( $pcols >= 1 ) {
    die <<"EOF";
** ERROR: invalid chunk size: $pcols
EOF
}

if ($print>=2) { print "Maximum number of columns in a chunk: $pcols$eol"; }

#-----------------------------------------------------------------------------------------------
# Maximum number of sub-columns in a chunk.
if (defined $opts{'psubcols'}) {
    $cfg_ref->set('psubcols', $opts{'psubcols'});
}
my $psubcols = $cfg_ref->get('psubcols');

# Check valid value of psubcols
unless ( $psubcols >= 1 ) {
    die <<"EOF";
** ERROR: invalid size for sub-columns: $psubcols
EOF
}

if ($print>=2) { print "Maximum number of sub-columns per column: $psubcols$eol"; }

#-----------------------------------------------------------------------------------------------
# Number of vertical levels
my $nlev = 0;

# Defaults
if ($waccmx) {
    if ($phys_pkg eq 'cam6') {
        $nlev = 130;
    } else {
        $nlev = 126;
    }
}
elsif ($chem_pkg =~ /waccm_/) {
    if ($phys_pkg eq 'cam4') {
        $nlev = 66;
    }
    else {
        $nlev = 70;
    }
}
elsif ($phys_pkg eq 'cam6') {
    $nlev = 32;
}
elsif ($phys_pkg eq 'cam5' or $phys_pkg eq 'spcam_m2005') {
    $nlev = 30;
}
elsif ($phys_pkg eq 'cam4' or $phys_pkg eq 'spcam_sam1mom') {
    $nlev = 26;
}
elsif ($phys_pkg eq 'cam3') {
    $nlev = 26;
}
else {
    # This will be used for Held-Suarez and other 'simple' physics
    # We may change this to 32 once IC files are available.
    $nlev = 30;
}

# user override
if (defined $opts{'nlev'}) {
    $nlev = $opts{'nlev'};
}

# Check valid value of nlev
unless ( $nlev >= 1 ) {
    die <<"EOF";
** ERROR: invalid number of vertical levels: $nlev
EOF
}

$cfg_ref->set('nlev', $nlev);

if ($print>=2) { print "Number of vertical levels: $nlev$eol"; }

if ($phys_pkg eq 'spcam_sam1mom' or $phys_pkg eq 'spcam_m2005') {
   $cfg_ref->set('spcam_nz', $nlev-2);
}

#------------------------------------------------------------------------------------------------
# chemistry preprocessor....
#  -- avoid using the chem_preprocessor unless it's required
#------------------------------------------------------------------------------------------------
my $chem_nadv = 0;
my $chem_cppdefs = '';
my $chem_src_dir = '';

if (!$prog_species) {
  $chem_src_dir = "$cam_dir/src/chemistry/pp_$chem_pkg";
  $cfg_ref->set('chem_src_dir', $chem_src_dir);
}

# customize chemistry
my $edit_chem_mech = $cfg_ref->get('edit_chem_mech');
my $usr_mech_infile = $cfg_ref->get('usr_mech_infile');
my $customize = $prog_species || $edit_chem_mech || $usr_mech_infile;

if ($customize) {
    # build_chem_proc option used to force a build even if an executable exists
    if (defined $opts{'build_chem_proc'}) {
        $cfg_ref->set('build_chem_proc', $opts{'build_chem_proc'});
    } else {
        $cfg_ref->set('build_chem_proc', 0);
    }
    my $chem_proc_src ;
    $chem_proc_src = "$cam_bld/chem_proc/source";
    $cfg_ref->set('chem_proc_src', $chem_proc_src) ;
    my $chemproc_fc;
    # determine which fortran compiler to use for building the preprocessor
    if (defined $opts{'fc_type'}) {
        $chemproc_fc = $opts{'fc_type'};
        if ($print>=2) { print "Chem preprocessor compiler set from fc config opt$eol"; }
    }
    if ($print>=2) { print "Chem preprocessor compiler: $chemproc_fc $eol"; }
    ($chem_nadv) = chem_preprocess($cfg_ref,$print,$chemproc_fc);
} elsif ($chem_pkg ne 'none') {
   # copy over chem docs
    copy("$chem_src_dir/chem_mech.doc",$cam_bld) or die "copy failed $! \n";
    copy("$chem_src_dir/chem_mech.in" ,$cam_bld) or die "copy failed $! \n";
    ($chem_nadv) = chem_number_adv($chem_src_dir);
}

if ($chem_pkg =~ '_mam3') {
    $chem_cppdefs = ' -DMODAL_AERO -DMODAL_AERO_3MODE ';
} elsif ($chem_pkg =~ '_mam4') {
    $chem_cppdefs = ' -DMODAL_AERO -DMODAL_AERO_4MODE ';
} elsif ($chem_pkg =~ '_mam7') {
    $chem_cppdefs = ' -DMODAL_AERO -DMODAL_AERO_7MODE ';
}

# CARMA sectional microphysics
#
# New CARMA models need to define the number of advected constituents.
#
# New CARMA models that want to do dry depostion need to provide the ccp_def PROGSSLT, so that
# clm will return aerodynamic resistances and surface friction velocity.
my $carma_nadv = 0;
my $carma_cppdefs = '';

if ($carma_pkg eq 'bc_strat') {
    $carma_nadv = 1;
}
elsif ($carma_pkg eq 'cirrus') {
    $carma_nadv = 84;
}
elsif ($carma_pkg eq 'cirrus_dust') {
    $carma_nadv = 140;
}
elsif ($carma_pkg eq 'dust') {
    $carma_nadv = 16;
}
elsif ($carma_pkg eq 'meteor_impact') {
    $carma_nadv = 42;
}
elsif ($carma_pkg eq 'meteor_smoke') {
    $carma_nadv = 28;
}
elsif ($carma_pkg eq 'mixed_sulfate') {
    $carma_nadv = 84;
}
elsif ($carma_pkg eq 'pmc') {
    $carma_nadv = 84;
}
elsif ($carma_pkg eq 'pmc_sulfate') {
    $carma_nadv = 140;
}
elsif ($carma_pkg eq 'sea_salt') {
    $carma_nadv = 16;
}
elsif ($carma_pkg eq 'sulfate') {
    $carma_nadv = 30;
}
elsif ($carma_pkg eq 'tholin') {
    $carma_nadv = 40;
}
elsif ($carma_pkg eq 'test_detrain') {
    $carma_nadv = 66;
}
elsif ($carma_pkg eq 'test_growth') {
    $carma_nadv = 32;
}
elsif ($carma_pkg eq 'test_passive') {
    $carma_nadv = 16;
}
elsif ($carma_pkg eq 'test_radiative') {
    $carma_nadv = 16;
}
elsif ($carma_pkg eq 'test_swelling') {
    $carma_nadv = 48;
}
elsif ($carma_pkg eq 'test_tracers') {
    $carma_nadv = 372;
}
elsif ($carma_pkg eq 'test_tracers2') {
    $carma_nadv = 434;
}


#-----------------------------------------------------------------------------------------------
# Number of advected constituents
my $nadv;
if (defined $opts{'nadv'}) {
    $cfg_ref->set('nadv', $opts{'nadv'});
}
else {

    # If the user hasn't specified the number of advected constituents via the -nadv
    # commandline arg, then determine the default number.

    # There is always at least one advected constituent, the specific humidity, even
    # if it's set to zero which is the case for adiabatic or Held-Suarez physics.
    $nadv = 1;

    # Chemistry package:
    $nadv += $chem_nadv;
    if ($print>=2) { print "Advected constituents added by chemistry $chem_pkg: $chem_nadv$eol"; }

    # If no 'simple' (e.g., Held-Suarez) physics package is used,
    # then accumulate advected constituents from the moist physics and
    # chemistry processes.

    unless ($simple_phys) {

        # Microphysics parameterization
        if ($microphys_pkg eq 'rk' or $microphys_pkg eq 'spcam_sam1mom') {
            $nadv += 2;
            if ($print>=2) { print "Advected constituents added by $microphys_pkg microphysics: 2$eol"; }
        }
        elsif ($microphys_pkg =~ /^mg1/ or $microphys_pkg eq 'spcam_m2005') {
            $nadv += 4;
            if ($print>=2) { print "Advected constituents added by $microphys_pkg microphysics: 4$eol"; }
        }
        elsif ($microphys_pkg =~/^mg2/) {
            $nadv += 8;
            if ($print>=2) { print "Advected constituents added by $microphys_pkg microphysics: 8$eol"; }
        }
        elsif ($microphys_pkg =~/^mg3/) {
            $nadv += 10;
            if ($print>=2) { print "Advected constituents added by $microphys_pkg microphysics: 10$eol"; }
        }

        if ($zmconv_org == 1 ) {
          $nadv += 1;
            if ($print>=2) { print "Advected constituents added by $microphys_pkg microphysics: 8$eol"; }
        }

        if ($clubb_do_adv) {
            $nadv += 9;
            if ($print>=2) { print "Advected constituents added by $microphys_pkg microphysics: 8$eol"; }
        }

        # co2_cycle
        if ($co2_cycle) {
            $nadv += 4;
            if ($print>=2) { print "Advected constituents added by co2_cycle: 4$eol"; }
        }

        # CARMA package:
        if ($carma_nadv > 0) {
            $nadv += $carma_nadv;
            if ($print>=2) { print "Advected constituents added by CARMA model $carma_pkg: $carma_nadv$eol"; }
        }

        # UNICON tracers
        if ($unicon) {
            $nadv += 5;
            if ($print>=2) { print "Advected constituents added by UNICON: 5$eol"; }
        }

    }

    # Special case for Kessler physics, need ice and water tracers
    if ($phys_pkg eq "kessler") {
      $nadv += 2
    }

    # Add in specified test tracers.  These may be present with 'simple' (e.g., Held-Suarez) physics.
    $nadv += $ttrac_nadv;
    if ($print>=2 and $ttrac_nadv) { print "Advected constituents added by test tracer package: $ttrac_nadv$eol"; }

    if ($age_of_air_trcs eq "ON") {
        $nadv += 4;
        if ($print>=2) { print "Advected constituents added by the age of air tracer package: 4$eol"; }
    }

    $cfg_ref->set('nadv', $nadv);
}

$nadv = $cfg_ref->get('nadv');
if ($print>=2) { print "Total advected constituents: $nadv$eol"; }

#-----------------------------------------------------------------------------------------------
# Makefile configuration #######################################################################
#-----------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------
# Check for GNU make in the user's path
if ($print) { print "Looking for a valid GNU make... "; }
my @makenames = qw(gmake gnumake make);
if ($opts{'gmake'}) { unshift @makenames, $opts{'gmake'}; }
my $gmake = get_gmake(@makenames);
if ($gmake) {
    if ($print) { print "using $gmake$eol"; }
} else {
    print "\n".
          "** Cannot find a valid GNU make.  Tried:\n".
          "@makenames\n";
    die "The name of GNU make on your system can be specified to configure via\n".
        "the -gmake option.  Make sure this\n".
        "name is in your path (add the appropriate directory to your PATH\n".
        "environment variable) or specify an absolute pathname.\n";
}

#-----------------------------------------------------------------------------------------------
# Name of CAM executable.
if (defined $opts{'cam_exe'}) {
    $cfg_ref->set('cam_exe', $opts{'cam_exe'});
}
my $cam_exe = $cfg_ref->get('cam_exe');

if ($print>=2) { print "Name of CAM executable: $cam_exe$eol"; }

#-----------------------------------------------------------------------------------------------
# Set default Fortran and C compilers
my $fc = '';
my $fc_type = '';
my $cc = '';

if ($target_os eq 'aix') {
    if ($spmd eq 'ON') {
        $fc = 'mpxlf95_r';
    }
    else {
        $fc = 'xlf95_r';
    }
    $fc_type = 'ibm';
    $cc = 'mpcc_r';
}
elsif ($target_os eq 'linux') {
    $fc='gfortran';
}
elsif ($target_os eq 'darwin') {

    my $uname_m = `uname -m`;
    if ($uname_m =~ /ppc/) {

        if ($spmd eq 'ON') {
            $fc = 'mpxlf95_r;'
        }
        else {
            $fc = 'xlf95_r';
        }
        $fc_type = 'ibm';
        $cc = 'xlc';
    }
    else {
        $fc = 'ifort';
        $cc = 'gcc';
    }
}
elsif ($target_os eq 'bgl') {
    $fc = 'blrts_xlf95';
    $cc = 'blrts_xlc';
}
elsif ($target_os eq 'bgp') {
    $fc = 'mpixlf95_r';
    $cc = 'mpixlc_r';
}
elsif ($target_os eq 'bgq') {
    $fc = 'mpixlf2003_r';
    $cc = 'mpixlc_r';
}

# User override for Fortran compiler
if (defined $opts{'fc'}) { $fc = $opts{'fc'}; }

if ($fc) {
    $cfg_ref->set('fc', $fc);
    if ($print>=2) { print "Fortran compiler: $fc$eol"; }
}
else {
    # If no default or user specification for Fortran compiler then die.
    die "Default for Fortran compiler not found.  Specify using the '-fc' argument.$eol";
}

# fc_type is used to identify the type of fortran compiler when it is being invoked
# using a generic name such as mpif90 or ftn.  This is currently only used in the Linux
# section of the Makefile.

if    ($fc =~ /pgf/)    { $fc_type = 'pgi'; }
elsif ($fc =~ /ifort/)  { $fc_type = 'intel'; }
elsif ($fc =~ /^nag/)   { $fc_type = 'nag'; }
elsif ($fc =~ /path/)   { $fc_type = 'pathscale'; }
elsif ($fc =~ /gfort/)  { $fc_type = 'gnu'; }
elsif ($fc =~ /xlf/)    { $fc_type = 'ibm'; }
elsif ($fc =~ /nvfor/)  { $fc_type = 'nvhpc'; }

# User override for Fortran compiler type
if (defined $opts{'fc_type'}) { $fc_type = $opts{'fc_type'}; }

if ($fc_type) {
    $cfg_ref->set('fc_type', $fc_type);
    if ($print>=2) { print "Fortran compiler type: $fc_type$eol"; }
}
else {

    # The Linux section of the Makefile depends on the FC_TYPE macro.  Fail if
    # target_os is linux and fc_type hasn't been set.
    if ($target_os eq 'linux') {
        die "Fortran compiler type must be set on Linux platform.  Specify using the '-fc_type' argument.$eol";
    }
}

# If a default hasn't been set yet for CC then set one now.
if ($cc eq '') {

    # On platforms where the programming environment is set up using a package managing
    # tool like "module" or "dotkit" then the compilers are invoked using scripts with
    # generic names like "ftn" and "cc".  The following code to set the default CC
    # compiler recognizes this special case:

    if ($fc eq 'ftn') {

        $cc = 'cc';

    }
    elsif ($fc eq 'mpif90') {

        $cc = 'mpicc';

    }
    else {

        # Set default C compiler based on fc_type
        if    ($fc_type eq 'pgi')       { $cc = 'pgcc'; }
        elsif ($fc_type eq 'intel')     { $cc = 'icc'; }
        elsif ($fc_type eq 'nag')       { $cc = 'gcc'; }
        elsif ($fc_type eq 'pathscale') { $cc = 'pathcc'; }
        elsif ($fc_type eq 'gnu')       { $cc = 'gcc'; }
        elsif ($fc_type eq 'ibm')       { $cc = 'xlc'; }
        elsif ($fc_type eq 'nvhpc')     { $cc = 'nvc'; }
    }
}

# User override for C compiler
if (defined $opts{'cc'}) { $cc = $opts{'cc'}; }

# If the C compiler has not been set yet...
unless ($cc) { $cc = 'cc';}

$cfg_ref->set('cc', $cc);
if ($print>=2) { print "C compiler: $cc$eol"; }


#-----------------------------------------------------------------------------------------------
# Allow override of Makefile default linker
my $linker = '';
if (defined $opts{'linker'}) {
    $linker = $opts{'linker'};
}
$cfg_ref->set('linker', $linker);

if ($linker and $print>=2) { print "Setting linker to: $linker$eol"; }

#-----------------------------------------------------------------------------------------------
# Use compiler debugging options?
my $debug_opt = (defined $opts{'debug'}) ? 1 : 0;
$cfg_ref->set('debug', $debug_opt);
my $debug = $debug_opt ? 'ON': 'OFF';

if ($print>=2) { print "Compiler debugging options: $debug$eol"; }

#-----------------------------------------------------------------------------------------------
# Append to Makefile default C compiler options
my $cflags = '';
if (defined $opts{'cflags'}) {
    $cflags = $opts{'cflags'};
}
$cfg_ref->set('cflags', $cflags);

if ($cflags and $print>=2) { print "Setting additional C compiler options: \'$cflags\'$eol"; }

#-----------------------------------------------------------------------------------------------
# Append to Makefile default Fortran compiler options
my $fflags = '';
if (defined $opts{'fflags'}) {
    $fflags = $opts{'fflags'};
}
$cfg_ref->set('fflags', $fflags);

if ($fflags and $print>=2) { print "Setting additional Fortran compiler options: \'$fflags\'$eol"; }

#-----------------------------------------------------------------------------------------------
# Fortran compiler optimization overrides Makefile defaults
my $fopt = '';
if (defined $opts{'fopt'}) {
    $fopt = $opts{'fopt'};
}
$cfg_ref->set('fopt', $fopt);

if ($fopt and $print>=2) { print "Override default Fortran optimization flags with: \'$fopt\'$eol"; }

#-----------------------------------------------------------------------------------------------
# Load options appended to Makefile defaults
my $ldflags = '';
my $usr_ldflags = '';
if (defined $opts{'ldflags'}) {
    $ldflags     = $opts{'ldflags'};
    # Save off the user specification to pass to the MCT configure
    $usr_ldflags = $opts{'ldflags'};
}
$cfg_ref->set('ldflags', $ldflags);

if ($ldflags and $print>=2) { print "Load options appended to Makefile defaults: \'$ldflags\'$eol"; }

#-----------------------------------------------------------------------------------------------
# For the CPP tokens, start with the specifications from the commandline.
my $usr_cppdefs = ' ';
if (defined $opts{'cppdefs'}) {
    $usr_cppdefs .= " $opts{'cppdefs'}";
}
$cfg_ref->set('cppdefs', $usr_cppdefs);

if ($usr_cppdefs and $print>=2) { print "Commandline CPP definitions: \'$usr_cppdefs\'$eol";}

# The following CPP macro definitions are used to implement the compile-time options.  They are
# determined by the configuration parameters that have been set above.  They will be appended to
# the CPP definitions that were explicitly set in the defaults file or by the user on the commandline.
my $cfg_cppdefs = ' ';

# Building for perturbation growth tests
if ($pergro eq "ON") { $cfg_cppdefs .= " -DPERGRO"; }

# Building for superparameterization
my $spcam_clubb_sgs = $cfg_ref->get('spcam_clubb_sgs');
my $spcam_nx        = $cfg_ref->get('spcam_nx');
my $spcam_ny        = $cfg_ref->get('spcam_ny');
my $spcam_nz        = $cfg_ref->get('spcam_nz');
my $spcam_dx        = $cfg_ref->get('spcam_dx');
my $spcam_dt        = $cfg_ref->get('spcam_dt');

my $yes3Dval        = 1;  # default to 3D for spcam
if ($spcam_ny eq 1) {$yes3Dval = 0;}  #Turn off if not using 3D

if ($phys_pkg eq 'spcam_m2005' or $phys_pkg eq 'spcam_sam1mom') {
    $cfg_cppdefs .= " -DSPCAM_NX=$spcam_nx -DSPCAM_NY=$spcam_ny -DSPCAM_NZ=$spcam_nz -DSPCAM_DX=$spcam_dx -DSPCAM_DT=$spcam_dt -DYES3DVAL=$yes3Dval -DCRM ";
    if ( $spcam_clubb_sgs == 1 )    {
        $cfg_cppdefs .= "-DSPCAM_CLUBB_SGS -DCLUBB_CRM -DCLUBB_REAL_TYPE=dp -DCLUBB_SAM";  ## -DNO_LAPACK_ISNAN";
    }
}

if ($phys_pkg eq 'spcam_m2005') {$cfg_cppdefs .= " -DECPP -Dm2005";}

if ($phys_pkg eq 'spcam_sam1mom') {$cfg_cppdefs .= "  -Dsam1mom";}

# Configure CAM to produce IOP files for SCAM
if ($camiop eq 'ON') { $cfg_cppdefs .= " -DBFB_CAM_SCAM_IOP"; }

# Resolution parameters for rectangular lat/lon grids
my $nlon = $cfg_ref->get('nlon');
my $nlat = $cfg_ref->get('nlat');
$cfg_cppdefs .= " -DPLON=$nlon -DPLAT=$nlat";

# Parameters for multiple instances
$cfg_cppdefs .= " -DNUM_COMP_INST_ATM=1 -DNUM_COMP_INST_LND=1 -DNUM_COMP_INST_OCN=1 -DNUM_COMP_INST_ICE=1";
$cfg_cppdefs .= " -DNUM_COMP_INST_GLC=1 -DNUM_COMP_INST_ROF=1 -DNUM_COMP_INST_WAV=1 -DNUM_COMP_INST_IAC=1";
$cfg_cppdefs .= " -DNUM_COMP_INST_ESP=1";

# Parameters for spectral element dycore.
# HAVE_F2003_PTR_BND_REMAP definition turns on standard-conforming method of causing edge
# buffers to overlap. This method works in all CAM compilers.
if ($dyn_pkg eq 'se') {

    my $csnp = $cfg_ref->get('csnp');
    $cfg_cppdefs .= " -DCAM  -D_WK_GRAD -DNP=$csnp -DHAVE_F2003_PTR_BND_REMAP";

    # Check to see if physics grid is being used
    my $npg = $cfg_ref->get('npg');
    if ($npg > 0) {
        $cfg_cppdefs .= " -DFVM_TRACERS";
    }

    if ($smp eq 'ON') {
        $cfg_cppdefs .= " -D_OPENMP";
    }

    if ($spmd eq 'ON') {
        $cfg_cppdefs .= " -D_MPI";
    }
}

# FV3 preprocessor symbols to use FMS decomposition functionality and more accurate FV3 thermodynamics.
if ($dyn_pkg eq 'fv3') {
    $cfg_cppdefs .= " -Duse_libMPI -Duse_netCDF -DUSE_COND -DMOIST_CAPPA";
}

# Resolution parameters for vertical grid, number of constituents, chunk size
my $nlev = $cfg_ref->get('nlev');
my $nadv = $cfg_ref->get('nadv');
my $pcols = $cfg_ref->get('pcols');
my $psubcols = $cfg_ref->get('psubcols');
$cfg_cppdefs .= " -DPLEV=$nlev -DPCNST=$nadv -DPCOLS=$pcols -DPSUBCOLS=$psubcols";

# Radiatively active constituent number
$cfg_cppdefs .= " -DN_RAD_CNST=$max_n_rad_cnst";

# Spectral truncation parameters
my $trm = $cfg_ref->get('trm');
my $trn = $cfg_ref->get('trn');
my $trk = $cfg_ref->get('trk');
$cfg_cppdefs .= " -DPTRM=$trm -DPTRN=$trn -DPTRK=$trk";

# offline driver for FV dycore
if ($offline_dyn) { $cfg_cppdefs .= ' -DOFFLINE_DYN'; }

# -DSPMD added for parallel builds.
if ($spmd eq 'ON') { $cfg_cppdefs .= " -DSPMD"; }

# Chem CPP defs
$cfg_cppdefs .= $chem_cppdefs;

# CARMA CPP defs
$cfg_cppdefs .= $carma_cppdefs;

#Analytic initial conditions for dynamics state?
if ($cfg_ref->get('analytic_ic')) {
  $cfg_cppdefs .= ' -DANALYTIC_IC';
}

#WACCM-X extended thermosphere/ionosphere model
if ($waccmx) {
    $cfg_cppdefs .= ' -DWACCMX_PHYS';
}

# PIO
my $pio2_build = (defined $opts{'pio2'}) ? 1 : 0;

# COSP simulator
if ($cosp) { $cfg_cppdefs .= ' -DUSE_COSP'; }

# CLUBB, hardcode CLUBB precision to kind=8
if ($clubb_sgs == 1) {
    $cfg_cppdefs .= ' -DCLUBB_SGS';
    $cfg_cppdefs .= ' -DCLUBB_CAM';
    $cfg_cppdefs .= ' -DNO_LAPACK_ISNAN';
    $cfg_cppdefs .= " -DCLUBB_REAL_TYPE=dp";
}
if ($silhs == 1) {
    $cfg_cppdefs .= ' -DSILHS';
}

# UNICON
if ($unicon) { $cfg_cppdefs .= ' -DUSE_UNICON'; }

#-----------------------------------------------------------------------------------------------
# CPP defines to put on Makefile

my $make_cppdefs = "$usr_cppdefs $cfg_cppdefs";

if ($print>=2) { print "CPP definitions set by configure: \'$cfg_cppdefs\'$eol"; }


#-----------------------------------------------------------------------------------------------
# COSP library.
if ($cosp) {

    # Set the directory used to build cosp.  Add location and library name
    # to the user specified load flags.
    my $cosp_libdir = '';
    if (defined $opts{'cosp_libdir'}) {
      $cosp_libdir = $opts{'cosp_libdir'};
    } else
    {
        $cosp_libdir = "$cam_bld/cosp";
    }

    $cfg_ref->set('cosp_libdir', "$cosp_libdir");

    my $ldflags = $cfg_ref->get('ldflags');
    $ldflags .= " -L$cosp_libdir -lcosp ";
    $cfg_ref->set('ldflags', $ldflags);

    # create the build directory for cosp
    my $bld_dir = $cosp_libdir;
    unless (-d $bld_dir or mkdirp($bld_dir)) {
        die "** Could not create the cosp build directory: $bld_dir\n";
    }

    # Create the COSP Makefile from a template and copy it into the cosp bld directory
    if ($print) { print "creating $cosp_libdir/Makefile\n"; }
    write_cosp_makefile("$cfgdir/../src/physics/cosp2/Makefile.in", "$cosp_libdir/Makefile");
}

#-----------------------------------------------------------------------------------------------
# FV3CORE library.
if ($dyn_pkg eq 'fv3') {
    # Set the directory used to build fv3core.  Add location and library name
    # to the user specified load flags.
    my $fv3core_libdir = '';
    if (defined $opts{'fv3core_libdir'}) {
      $fv3core_libdir = $opts{'fv3core_libdir'};
    } else
    {
	$fv3core_libdir = "$cam_bld/atmos_cubed_sphere";
    }

    $cfg_ref->set('fv3core_libdir', "$fv3core_libdir");

    my $ldflags = $cfg_ref->get('ldflags');
    $ldflags .= " -L$fv3core_libdir -lfv3core ";
    $cfg_ref->set('ldflags', $ldflags);

    # create the build directory for fv3core
    unless (-d $fv3core_libdir or mkdirp($fv3core_libdir)) {
        die "** Could not create the fv3core build directory: $fv3core_libdir\n";
    }

    # Write the filepath file.
    if ($print) { print "creating $fv3core_libdir/Filepath\n"; }
    write_fv3core_filepath("$fv3core_libdir/Filepath", $cfg_ref);

    # Create the FV3CORE Makefile from a template and copy it into the fv3core bld directory
    if ($print) { print "creating $fv3core_libdir/Makefile\n"; }
    write_fv3_makefile("$cam_dir/src/dynamics/fv3/Makefile.in.fv3",  "$fv3core_libdir/Makefile");
}

#-----------------------------------------------------------------------------------------------
# MPAS library.
if ($dyn_pkg eq 'mpas') {

    # Set the directory used to build MPAS.  Add location and library name
    # to the user specified load flags.
    my $mpas_libdir = '';
    if (defined $opts{'mpas_libdir'}) {
      $mpas_libdir = $opts{'mpas_libdir'};
    } else
    {
        $mpas_libdir = "$cam_bld/mpas";
    }

    $cfg_ref->set('mpas_libdir', "$mpas_libdir");

    my $ldflags = $cfg_ref->get('ldflags');
    $ldflags .= " -L$mpas_libdir -lmpas ";
    $cfg_ref->set('ldflags', $ldflags);

    # create the build directory for mpas
    my $bld_dir = $mpas_libdir;
    unless (-d $bld_dir or mkdirp($bld_dir)) {
        die "** Could not create the mpas build directory: $bld_dir\n";
    }

    # Create the MPAS Makefile from a template and copy it into the mpas bld directory
    write_mpas_makefile("$cfgdir/../src/dynamics/mpas/Makefile", "$mpas_libdir/Makefile");
    if ($print) { print "creating $mpas_libdir/Makefile\n"; }
}

#-----------------------------------------------------------------------------------------------
# Write configuration files ####################################################################
#-----------------------------------------------------------------------------------------------

my $fp_filename      = 'Filepath';             # name of output filepath file
my $cpp_filename     = 'CESM_cppdefs';         # name of output file for CAM's cppdefs in cesm

# Write the filepath file.
if ($print) { print "creating $cam_bld/$fp_filename\n"; }
write_filepath("$cam_bld/$fp_filename", $cfg_ref);

# Write the file for CAM's cppdefs needed in CESM.
if ($print) { print "creating $cam_bld/$cpp_filename\n"; }
write_cppdefs("$cam_bld/$cpp_filename", $make_cppdefs);

# Write the configuration cache file.
if ($print) { print "creating $config_cache_file\n"; }
$cfg_ref->write_file($config_cache_file, $commandline);

#-------------------------------------------------------------------------------

sub write_fv3core_filepath
{
    my ($file, $cfg_ref) = @_;
    my  $fh = new IO::File;

    $fh->open(">$file") or die "** can't open filepath file: $file\n";
    my $camsrcdir   = $cfg_ref->get('cam_dir');
    my $CASEROOT = "$ENV{'CASEROOT'}";
    print $fh "$CASEROOT/SourceMods/src.cam\n";
    print $fh "$camsrcdir/src/dynamics/fv3/microphys\n";
    print $fh "$camsrcdir/src/dynamics/fv3/atmos_cubed_sphere/model\n";
    print $fh "$camsrcdir/src/dynamics/fv3/atmos_cubed_sphere/tools\n";

    $fh->close;
}
#-------------------------------------------------------------------------------
sub write_filepath
{
    my ($file, $cfg_ref) = @_;
    my  $fh = new IO::File;

    $fh->open(">$file") or die "** can't open filepath file: $file\n";

    # configuration parameters used to determine paths
    my $cam_root      = $cfg_ref->get('cam_root');
    my $usr_src       = $cfg_ref->get('usr_src');
    my $chem_proc_src = $cfg_ref->get('chem_proc_src');
    my $chem_src_dir  = $cfg_ref->get('chem_src_dir');
    my $chem          = $cfg_ref->get('chem');
    my $waccm_phys    = $cfg_ref->get('waccm_phys');
    my $waccmx        = $cfg_ref->get('waccmx');
    my $ionos         = $cfg_ref->get('ionosphere');
    my $carma         = $cfg_ref->get('carma');
    my $rad           = $cfg_ref->get('rad');
    my $dyn           = $cfg_ref->get('dyn');
    my $cppdefs       = $cfg_ref->get('cppdefs');
    my $cosp          = $cfg_ref->get('cosp');
    my $spmd          = $cfg_ref->get('spmd');
    my $offline_drv   = $cfg_ref->get('offline_drv');
    my $inic_val      = $cfg_ref->get('analytic_ic');

    # Root directory
    my $camsrcdir = $cfg_ref->get('cam_dir');

    # Start writing paths to the file.  *** Order is important ***  The
    # sequence of paths will be used to set the GNU Makefile's VPATH macro
    # which tells make where to search for dependencies.

    # User specified source directories.
    if ($usr_src  =~ /\S+/) {
        my @dirs = split ',', $usr_src;
        while ( my $dir = shift @dirs ) {
            print $fh "$dir\n";
        }
    }

    # CESM has a standard source mods location.
    my $CASEROOT = "$ENV{'CASEROOT'}";
    print $fh "$CASEROOT/SourceMods/src.cam\n";

    # offline unit driver (defaults to stub)
    print $fh "$camsrcdir/src/unit_drivers\n";
    print $fh "$camsrcdir/src/unit_drivers/${offline_drv}\n";

    if ($simple_phys) {
      print $fh "$camsrcdir/src/physics/simple\n";
      print $fh "$camsrcdir/src/atmos_phys/kessler\n";
      print $fh "$camsrcdir/src/atmos_phys/held_suarez\n";
    }

    # Weak scaling fix. This has to come before physics/cam and before dycores
    # It also has to come before utils (which is already near the end).
    if ($dyn eq 'se' or $dyn eq 'mpas') {
      print $fh "$camsrcdir/src/infrastructure\n";
    }

    if ($carma ne 'none') {
        # This directory needs to precede physics/cam/ to replace
        # the CARMA stub package with CARMA. Putting it first allows
        # any CAM file to be overridden by a particular CARMA model.
        print $fh "$camsrcdir/src/physics/carma/models/$carma\n";
        print $fh "$camsrcdir/src/physics/carma/cam\n";
        print $fh "$camsrcdir/src/physics/carma/base\n";
    }

    # CAM chemistry, dynamics, physics, control and shared utilities.
    if ($chem_proc_src) {
        print $fh "$chem_proc_src\n";
    }
    if ($chem_src_dir) {
        print $fh "$chem_src_dir\n";
    }
    if ($chem =~ /_mam/) {
        print $fh "$camsrcdir/src/chemistry/modal_aero\n";
    } else {
        print $fh "$camsrcdir/src/chemistry/bulk_aero\n";
    }
    print $fh "$camsrcdir/src/chemistry/aerosol\n";

    if ($waccmx) {
        print $fh "$camsrcdir/src/physics/waccmx\n";
        if ($ionos =~ /wxie/) {
            print $fh "$camsrcdir/src/ionosphere/waccmx\n";
        }
    }
    if ($waccm_phys) {
        print $fh "$camsrcdir/src/physics/waccm\n";
    }
    print $fh "$camsrcdir/src/ionosphere\n";

    print $fh "$camsrcdir/src/chemistry/mozart\n";
    print $fh "$camsrcdir/src/chemistry/utils\n";

    if ($rad eq 'rrtmg') {
        print $fh "$camsrcdir/src/physics/rrtmg\n";
        print $fh "$camsrcdir/src/physics/rrtmg/aer_src\n";
    }
    elsif ($rad eq 'camrt') {
        print $fh "$camsrcdir/src/physics/camrt\n";
    }

    if ($clubb_sgs) {
       print $fh "$camsrcdir/src/physics/clubb\n";
    }

    if ($silhs) {
       print $fh "$camsrcdir/src/physics/silhs\n";
    }

    print $fh "$camsrcdir/src/physics/pumas\n";

    # Superparameterization
    if ($phys_pkg eq 'spcam_m2005' or $phys_pkg eq 'spcam_sam1mom') {
        print $fh "$camsrcdir/src/physics/spcam\n";
        print $fh "$camsrcdir/src/physics/spcam/crm\n";

        # add additional directories for sam6.10.4
        print $fh "$camsrcdir/src/physics/spcam/crm/ADV_MPDATA\n";
        if ($phys_pkg eq 'spcam_sam1mom') {
           print $fh "$camsrcdir/src/physics/spcam/crm/MICRO_SAM1MOM\n";
        }
        if ($phys_pkg eq 'spcam_m2005') {
              print $fh "$camsrcdir/src/physics/spcam/crm/MICRO_M2005\n";
              print $fh "$camsrcdir/src/physics/spcam/ecpp\n";
        }
        if ( $spcam_clubb_sgs == 1 ) {
           print $fh "$camsrcdir/src/physics/spcam/crm/CLUBB\n";
           print $fh "$camsrcdir/src/physics/spcam/crm/SGS_CLUBBkvhkvm\n"
        }
        else {
           print $fh "$camsrcdir/src/physics/spcam/crm/SGS_TKE\n";
        }
    }

    # This directory contains much of the code for physics packages,
    # as well as the cam specific interface modules that may need to
    # be overridden by modules from directories that occur earlier
    # in the list of filepaths.
    print $fh "$camsrcdir/src/physics/cam\n";

    # Dynamics package and test utilities
    print $fh "$camsrcdir/src/dynamics/$dyn\n";
    if($dyn eq 'se') {
       print $fh "$camsrcdir/src/dynamics/se/dycore\n";
    }
    print $fh "$camsrcdir/src/dynamics/tests\n";
    if($inic_val) {
       print $fh "$camsrcdir/src/dynamics/tests/initial_conditions\n";
    }

    # Parallelization utilies
    if ($dyn eq 'fv' or $cppdefs =~ /MODCM_DP_TRANSPOSE/) {
        print $fh "$camsrcdir/src/utils/pilgrim\n";
    }

    # Advective transport
    if ($dyn eq 'eul') {
        print $fh "$camsrcdir/src/advection/slt\n";
    }

    print $fh "$camsrcdir/src/cpl/$cpl\n";
    print $fh "$camsrcdir/src/control\n";
    print $fh "$camsrcdir/src/utils\n";
    print $fh "$camsrcdir/src/atmos_phys/utilities\n";


    $fh->close;
}

#-------------------------------------------------------------------------------

sub write_cppdefs
{
    my ($file, $make_cppdefs) = @_;
    my  $fh = new IO::File;

    $fh->open(">$file") or die "** can't open cpp defs file: $file\n";

    print $fh "$make_cppdefs\n";

    $fh->close;
}

#-------------------------------------------------------------------------------

sub write_cosp_makefile
{

    my ($file_in, $file_out) = @_;
    my  $fh_in = new IO::File;
    my  $fh_out = new IO::File;

    $fh_out->open(">$file_out") or die "** can't open file: $file_out\n";

    print $fh_out  <<"EOF";

CAM_BLD      := $cam_bld
COSP_PATH    := $cam_dir/src/physics/cosp2
ISCCP_PATH   := $cam_dir/src/physics/cosp2/src/simulator/icarus
RS_PATH      := $cam_dir/src/physics/cosp2/src/simulator/quickbeam
RT_PATH      := $cam_dir/src/physics/cosp2/src/simulator/rttov
CS_PATH      := $cam_dir/src/physics/cosp2/src/simulator/actsim
MISR_PATH    := $cam_dir/src/physics/cosp2/src/simulator/MISR_simulator
MODIS_PATH   := $cam_dir/src/physics/cosp2/src/simulator/MODIS_simulator
PARASOL_PATH := $cam_dir/src/physics/cosp2/src/simulator/parasol

EOF

    # Copy the "template" makefile to the new makefile.
    $fh_in->open("<$file_in") or die "** can't open file: $file_in\n";
    while (<$fh_in>) {
        print $fh_out $_;
    }

    $fh_out->close;
    $fh_in->close;
}


#-------------------------------------------------------------------------------
sub write_fv3_makefile
{

    my ($file_in, $file_out) = @_;
    my  $fh_in = new IO::File;
    my  $fh_out = new IO::File;

    $fh_out->open(">$file_out") or die "** can't open file: $file_out\n";

    print $fh_out  <<"EOF";

CAM_BLD      := $cam_bld

EOF

    # Copy the "template" makefile to the new makefile.
    $fh_in->open("<$file_in") or die "** can't open file: $file_in\n";
    while (<$fh_in>) {
        print $fh_out $_;
    }

    $fh_out->close;
    $fh_in->close;
}


#-------------------------------------------------------------------------------

sub write_mpas_makefile
{

    my ($file_in, $file_out) = @_;
    my  $fh_in = new IO::File;
    my  $fh_out = new IO::File;

    $fh_out->open(">$file_out") or die "** can't open file: $file_out\n";

    print $fh_out  <<"EOF";

MPAS_SRC_ROOT := $cam_dir/src/dynamics/mpas
COMP_INTERFACE:= $cpl

EOF

    # Copy the "template" makefile to the new makefile.
    $fh_in->open("<$file_in") or die "** can't open file: $file_in\n";
    while (<$fh_in>) {
        print $fh_out $_;
    }

    $fh_out->close;
    $fh_in->close;
}


#-------------------------------------------------------------------------------

sub write_config_h
{
    my ($file) = @_;
    my  $fh = new IO::File;

    $fh->open(">$file") or die "** can't open config.h file for MCT: $file\n";

    print $fh <<"EOF";
#ifdef FORTRAN_SAME
#define FC_FUNC(name,NAME) name
#elif FORTRANUNDERSCORE
#define FC_FUNC(name,NAME) name ##_
#elif FORTRANDOUBLEUNDERSCORE
#define FC_FUNC(name,NAME)  name ##__
#endif
EOF

    $fh->close;
}

#-------------------------------------------------------------------------------

sub set_horiz_grid
{
    # Set parameters for the specified dycore and horizontal grid.
    #
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($hgrid_file, $cfg_ref) = @_;

    # Get dycore/grid from the configuration object
    my $dyn_pkg = $cfg_ref->get('dyn');
    my $hgrid   = $cfg_ref->get('hgrid');

    if ( $dyn_pkg eq 'se') {

        # For SE dycore parse the parameters out of the grid specifier string.

        $hgrid =~ m/ne(\d+)np(\d+)/;
        $cfg_ref->set('csne', $1);
        $cfg_ref->set('csnp', $2);

        my $npg = 0;
        if ($hgrid =~ m/\.pg(\d+)/) { $npg = $1; }
        $cfg_ref->set('npg',  $npg);

        # To allow more flexibility when matching grid attributes in the namelist
        # defaults file split the GLL and physics grid specifiers in the hgrid
        # argument to configure, and just store the GLL part in the hgrid parameter of
        # the config_cache file.  The physics grid specifier is stored separately
        # in the npg parameter.

        $hgrid =~ s/\.pg\d+//;   # strip the '.pgN' extension
        $cfg_ref->set('hgrid', $hgrid);
    }
    elsif ( $dyn_pkg eq 'fv3') {
        # For FV3 dycore parse the parameters out of the grid specifier string.
        $hgrid =~ m/C(\d+)/;
        $cfg_ref->set('hgrid', $hgrid);
    }
    elsif ($dyn_pkg =~ m/^eul$|^fv/) {

        # For EUL and FV dycores the parameters are read from an input file,
        # and if no dycore/grid matches are found then issue error message.

        my $xml = XML::Lite->new( $hgrid_file );
        my $root = $xml->root_element();

        # Check for valid root node
        my $name = $root->get_name();
        $name eq "config_horiz_grid" or die
            "file $hgrid_file is not a horizontal grid parameters file\n";

        # Read the grid parameters from $hgrid_file.
        my @e = $xml->elements_by_name( "horiz_grid" );
        my %a = ();

        # Search for matching dycore/grid.
        my $found = 0;
        HGRID: while ( my $e = shift @e ) {
            %a = $e->get_attributes();
            if ( $dyn_pkg eq $a{'dyn'} and $hgrid eq $a{'hgrid'} ) {
                $found = 1;
                last HGRID;
            }
        }

        # Die unless search was successful.
        unless ($found) { die "set_horiz_grid: no match for dycore $dyn_pkg and hgrid $hgrid\n"; }

        # Set parameter values -- dycore specific.
        if ( $dyn_pkg =~ m/eul/ ) {
            $cfg_ref->set('nlat', $a{'nlat'});
            $cfg_ref->set('nlon', $a{'nlon'});
            $cfg_ref->set('trm',  $a{'m'});
            $cfg_ref->set('trn',  $a{'n'});
            $cfg_ref->set('trk',  $a{'k'});

            # Override resolution settings to configure for SCAM mode.  The override is needed
            # because in SCAM mode the -hgrid option is used to specify the resolution of default
            # datasets from which single data columns are extracted.
            my $scam = $cfg_ref->get('scam');
            if ($scam) {
                $cfg_ref->set('nlat', 1);
                $cfg_ref->set('nlon', 1);
                $cfg_ref->set('trm',  1);
                $cfg_ref->set('trn',  1);
                $cfg_ref->set('trk',  1);
            }
        }
        elsif ( $dyn_pkg eq 'fv' ) {
            $cfg_ref->set('nlat', $a{'nlat'});
            $cfg_ref->set('nlon', $a{'nlon'});
        }
        else {
            die "set_horiz_grid: unrecognized dycore: $dyn_pkg\n";
        }
    }
}

#-------------------------------------------------------------------------------

sub absolute_path {
#
# Convert a pathname into an absolute pathname, expanding any . or .. characters.
# Assumes pathnames refer to a local filesystem.
# Assumes the directory separator is "/".
#
  my $path = shift;
  my $cwd = getcwd();  # current working directory
  my $abspath;         # resulting absolute pathname

# Strip off any leading or trailing whitespace.  (This pattern won't match if
# there's embedded whitespace.
  $path =~ s!^\s*(\S*)\s*$!$1!;

# Convert relative to absolute path.

  if ($path =~ m!^\.$!) {          # path is "."
      return $cwd;
  } elsif ($path =~ m!^\./!) {     # path starts with "./"
      $path =~ s!^\.!$cwd!;
  } elsif ($path =~ m!^\.\.$!) {   # path is ".."
      $path = "$cwd/..";
  } elsif ($path =~ m!^\.\./!) {   # path starts with "../"
      $path = "$cwd/$path";
  } elsif ($path =~ m!^[^/]!) {    # path starts with non-slash character
      $path = "$cwd/$path";
  }

  my ($dir, @dirs2);
  my @dirs = split "/", $path, -1;   # The -1 prevents split from stripping trailing nulls
                                     # This enables correct processing of the input "/".

  # Remove any "" that are not leading.
  for (my $i=0; $i<=$#dirs; ++$i) {
      if ($i == 0 or $dirs[$i] ne "") {
          push @dirs2, $dirs[$i];
      }
  }
  @dirs = ();

  # Remove any "."
  foreach $dir (@dirs2) {
      unless ($dir eq ".") {
          push @dirs, $dir;
      }
  }
  @dirs2 = ();

  # Remove the "subdir/.." parts.
  foreach $dir (@dirs) {
    if ( $dir !~ /^\.\.$/ ) {
        push @dirs2, $dir;
    } else {
        pop @dirs2;   # remove previous dir when current dir is ..
    }
  }
  if ($#dirs2 == 0 and $dirs2[0] eq "") { return "/"; }
  $abspath = join '/', @dirs2;
  return( $abspath );
}

#-------------------------------------------------------------------------------

sub subst_env_path {
#
# Substitute for any environment variables contained in a pathname.
# Assumes the directory separator is "/".
#
  my $path = shift;
  my $newpath;         # resulting pathname

# Strip off any leading or trailing whitespace.  (This pattern won't match if
# there's embedded whitespace.
  $path =~ s!^\s*(\S*)\s*$!$1!;

  my ($dir, @dirs2);
  my @dirs = split "/", $path, -1;   # The -1 prevents split from stripping trailing nulls
                                     # This enables correct processing of the input "/".

  foreach $dir (@dirs) {
    if ( $dir =~ /^\$(.+)$/ ) {
        push @dirs2, $ENV{$1};
    } else {
        push @dirs2, $dir;
    }
  }
  $newpath = join '/', @dirs2;
  return( $newpath );
}

#-------------------------------------------------------------------------------

sub mkdirp {
    my ($dir) = @_;
    my (@dirs) = split /\//, $dir;
    my (@subdirs, $path);

    # if $dir is absolute pathname then @dirs will start with ""
    if ($dirs[0] eq "") { push @subdirs, shift @dirs; }

    while ( @dirs ) { # check that each subdir exists and mkdir if it doesn't
        push @subdirs, shift @dirs;
        $path = join '/', @subdirs;
        unless (-d $path or mkdir($path, 0777)) { return 0; }
    }
    return 1;
}

#-------------------------------------------------------------------------------

sub get_cmake_version {

# Return CMake version.  Null string returned if cmake not found.

    my $retval = `cmake --version 2>&1`;
    $retval =~ /cmake version (\d+.*)/;  # use loose match for version string
    return $1;
}

#-------------------------------------------------------------------------------

sub get_gmake {

# check for a valid version of GNU make in the user's path

    my @makenames = @_;
    my ($make, $retval);

    foreach $make (@makenames) {
        $retval = `$make -v 2>&1`;
        return $make if ($retval =~ /GNU Make/);
    }
    return;
}

#-------------------------------------------------------------------------------

sub version {
# The version is found in CAM's ChangeLog file.
# $cfgdir is set by the configure script to the name of its directory.

    my ($cfgdir) = @_;

    my $logfile = "$cfgdir/../doc/ChangeLog";

    my $fh = IO::File->new($logfile, '<') or die "** can't open ChangeLog file: $logfile\n";

    while (my $line = <$fh>) {

        if ($line =~ /^Tag name:\s*(\w+)/ ) {
            print "$1\n";
            exit;
        }
    }

}
